#!/usr/bin/python -u

import sys
import os
import re
import select
import json

# md5 fallback if python <= 2.4
try:
  from hashlib import md5
except ImportError:
  from md5 import new as md5

import subprocess
import time

import hxrd.util

def build_cache_set(path, cached_files):
  if os.path.isdir(path):
    files = os.listdir(path)

    for f in files:
      abs_path = os.path.join(path, f)
      build_cache_set(abs_path, cached_files)
  else:
    if path.endswith('.cinfo'):
      cached_files.add(re.sub(r'___[0-9]+_[0-9]+.cinfo$', '', path).replace(CONF['CACHE_DIR'], CONF['LOGICAL_DIR'], 1))

def get_broken_files(path):
  broken_files = []

  p = subprocess.Popen(['hdfs', 'fsck', path], stdout=subprocess.PIPE, stderr=subprocess.PIPE)

  for line in p.stdout:
    m = re.match(r'([^:]+):.*MISSING.*blocks', line)
    if m is not None:
      broken_files.append(m.group(1))

  # just throw out stderr for now
  for line in p.stderr:
    pass

  p.wait()

  return broken_files

LOG_LEVEL = 0
LOG_OUT = sys.stdout
CONF_PATH = '@sysconfdir@/hdfs-xrootd-healer/hdfs-xrootd-healer.cfg'
STATE_DIR = '@localstatedir@/lib/hdfs-xrootd-healer'
LIBEXEC_DIR = '@libexecdir@/hdfs-xrootd-healer'
CONF = hxrd.util.parse_conf(CONF_PATH)
PRETEND = False
#DEBUG = False

if __name__ == '__main__':
  for a in sys.argv[1:]:
    if a == '-pretend':
      PRETEND = True
    #elif a == '-debug':
    #  DEBUG = True
    else:
      CONF['NAMESPACE'] = a

  log = hxrd.util.Logger(os.path.join(CONF['LOG_DIR'], "hdfs-xrootd-healer.log"))

  broken_files_tot = 0
  repairable_files_tot = 0
  repaired_files_tot = 0

  stat_dict = {
    'totals': {
      'broken_files': 0,
      'repairable_files': 0,
      'repaired_files': 0
    },
    'failed': {}
  }

  for ns_path in CONF['NAMESPACE'].split(','):
    log.log(0, "Processing namespace: %s" % ns_path)

    log.log(0, "Searching namespace for corrupt files")
    broken_files = get_broken_files(ns_path)

    if len(broken_files) == 0:
      log.log(0, "No corrupt files found")
      continue

    stat_dict['totals']['broken_files'] += len(broken_files)
    log.log(0, "Corrupt Files: %s" % len(broken_files))

    log.log(0, "Generating list of cached files")
    cached_files = set()
    build_cache_set(ns_path.replace(CONF['LOGICAL_DIR'], CONF['CACHE_DIR'], 1), cached_files)
    if len(cached_files) == 0:
      log.log(0, "No cached files found")
      continue

    log.log(0, "Cached Files: %s" % len(cached_files))

    repairable_files = 0
    repaired_files = 0

    file_bins = [[] for i in range(CONF['NUM_WORKERS'])]

    for f in broken_files:
      if f in cached_files:
        file_bins[repairable_files % len(file_bins)].append(f)
        repairable_files += 1

    # write file_list files for worker processes
    for i in range(len(file_bins)):
      fout = open(os.path.join(STATE_DIR, "file_list.%i.txt" % i), 'w')

      for f in file_bins[i]:
        fout.write("%s\n" % f)

      fout.close()

    log.log(0, "Repairable Files: %s" % repairable_files)

    log.log(0, "Begin repairing files")

    streams = []
    proc_map = {}
    for i in range(len(file_bins)):
      args = ['%s/hdfs-xrootd-hworker' % LIBEXEC_DIR]
      if PRETEND:
        args.append('-pretend')
      args += [str(i), CONF_PATH, os.path.join(STATE_DIR, "file_list.%i.txt" % i)]

      p = subprocess.Popen(args, stdout=subprocess.PIPE)

      # given a stream, remember the process object and its assigned id
      proc_map[p.stdout] = (p, i)
      streams.append(p.stdout)

    while True:
      ready_streams = select.select(streams,(),())
      for fin in ready_streams[0]:
        '''line = fin.readline()
        if line == '':
          # if stream closed child is about to exit
          proc_map[fin].wait()
          streams.remove(fin)
        else:
          repaired_files += int(line)
        '''

        proc = proc_map[fin]
        child_stats = json.load(fin)
        proc[0].wait()
        streams.remove(fin)

        repaired_files += child_stats['repaired_files']

        for f in child_stats['failed']:
          if f not in stat_dict['failed']:
            stat_dict['failed'][f] = {'freq': 0}

          stat_dict['failed'][f]['freq'] += 1
          stat_dict['failed'][f]['last_err_type'] = child_stats['failed'][f]['last_err_type']
          stat_dict['failed'][f]['last_worker'] = proc[1]

      if len(streams) == 0:
        break

    stat_dict['totals']['repairable_files'] += repairable_files
    stat_dict['totals']['repaired_files'] += repaired_files
    log.log(0, "Repaired Files: %s" % repaired_files)

  fout = open(os.path.join(STATE_DIR, 'stats.json'), 'w')
  json.dump(stat_dict, fout)
  fout.close()

  log.log(0, "Total Corrupt Files: %s" % stat_dict['totals']['broken_files'])
  log.log(0, "Total Repairable Files: %s" % stat_dict['totals']['repairable_files'])
  log.log(0, "Total Repaired Files: %s" % stat_dict['totals']['repaired_files'])

  log.close()
